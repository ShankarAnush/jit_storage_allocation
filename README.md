# Just-in-time Storage Allocation

## Summary
Storage as one of the resource allocation is gaining attention from recent days. Even small and mid-size organizations are choosing storage virtualization to reduce their CAPEX and OPEX. Understanding the behavior of the application to decide on the pattern of its disk usage is quintessential for knowing its storage requirements. Understanding the dynamics of the application also helps in choosing one of the applications from the pool of similar application. This thesis focuses on two phases, namely -- Benchmarking stateful application and designing RL based storage allocator. Apache Kafka, Apache Cassandra, MySQL, Redis and RabbitMQ were the five applications benchmarked. The applications were represented in both compressed and uncompressed formats. These applications were classified into four different classes based on their behavior, namely -- Bounded, Bounded and Oscillating, Unbounded, Unbounded and Oscillating. RabbitMQ was classified into \textBounded, Kafka into Bounded and Oscillating, MySQL and Cassandra (uncompressed) were classified into Unbounded, and Redis and Cassandra (compressed) were classified into Unbounded and Oscillating. Regression and lstm models were built to represent the classes. The model built was used as an input instead of the actual benchmarked data, so that the rl agent could be trained indefinitely. Current day storage allocation uses either static allocation techniques or Thick Provisioning. Either of them do not tend to optimize the Downtime and the Unused Disk Space of an application. A rl agent is trained to achieve this objective of optimizing the Downtime and the Unused Disk Space by deciding on a reward policy. The agent transitions from one state to another by choosing an action. The policy designed helps the agent to choose the best possible action from the set of available actions. An appropriate reward is given for the action taken by the agent. Four rl based storage allocators were implemented for four classes of stateful applications. The built rl agents prioritize the metric the Unused Disk Space over the Downtime of the application. Four gsa were designed that dynamically allocates the storage space, but that follows Thick Provisioning.\par

 The gsa and the rlsa were compared and evaluated against the actual data to inspect how precisely do both storage allocators allocate. Based on the current market price provided by Azure pricing calculator, the Downtime and the Unused Disk Space of each storage allocators for each class were assigned certain costs. The cost analysis carried during evaluation phase revealed the following. For Bounded class, the gsa allocates storage better than the rlsa. gsa over allocates but within the set threshold, whereas the rlsa under allocates at all instants of the application runtime. The cost incurred due to under allocating storage is out of the scope of this thesis, but it is observed that the agent continuously takes action because of the difference between rds and the ads. The allocation becomes so fine-grained and the Downtime keeps accumulating. Observing the storage allocated by the rl agent, I conclude that the agent designed for the Bounded class require more episodes of training to come-up with a storage allocator that decides better. Even though there is no cost incurred on Unused Disk Space from the rlsa, there is an unknown cost incurred due to under allocating storage. Concluding on which storage allocator would suit the class better is difficult at this point in time. Storage allocated for applications in the class Bounded and Oscillating depicts that the cost involved while using the gsa is too high compared to the rlsa. The cost incurred was due to Unused Disk Space in the gsa. Although there is a cost incurred due to application downtime, in the rlsa, it is negligible to that of the total cost of gsa. 
