# Just-in-time Storage Allocation

## Summary
Storage as one of the resource allocation is gaining attention from recent days. Even small and mid-size organizations are choosing storage virtualization to reduce their CAPEX and OPEX. Understanding the behavior of the application to decide on the pattern of its disk usage is quintessential for knowing its storage requirements. Understanding the dynamics of the application also helps in choosing one of the applications from the pool of similar application. This thesis focuses on two phases, namely -- Benchmarking stateful application and designing RL based storage allocator. Apache Kafka, Apache Cassandra, MySQL, Redis and RabbitMQ were the five applications benchmarked. The applications were represented in both compressed and uncompressed formats. These applications were classified into four different classes based on their behavior, namely -- Bounded, Bounded and Oscillating, Unbounded, Unbounded and Oscillating. RabbitMQ was classified into \textBounded}, Kafka into \texttt{Bounded and Oscillating}, MySQL and Cassandra (uncompressed) were classified into \texttt{Unbounded}, and Redis and Cassandra (compressed) were classified into \texttt{Unbounded and Oscillating}. Regression and \ac{lstm} models were built to represent the classes. The model built was used as an input instead of the actual benchmarked data, so that the \ac{rl} agent could be trained indefinitely. Current day storage allocation uses either static allocation techniques or \texttt{Thick Provisioning}. Either of them do not tend to optimize the \texttt{Downtime} and the \texttt{Unused Disk Space} of an application. A \ac{rl} agent is trained to achieve this objective of optimizing the \texttt{Downtime} and the \texttt{Unused Disk Space} by deciding on a reward policy. The agent transitions from one state to another by choosing an action. The policy designed helps the agent to choose the best possible action from the set of available actions. An appropriate reward is given for the action taken by the agent. Four \ac{rl} based storage allocators were implemented for four classes of stateful applications. The built \ac{rl} agents prioritize the metric the \texttt{Unused Disk Space} over the \texttt{Downtime} of the application. Four \ac{gsa} were designed that dynamically allocates the storage space, but that follows \texttt{Thick Provisioning}.\par

% The \ac{gsa} and the \ac{rlsa} were compared and evaluated against the actual data to inspect how precisely do both storage allocators allocate. Based on the current market price provided by Azure pricing calculator, the \texttt{Downtime} and the \texttt{Unused Disk Space} of each storage allocators for each class were assigned certain costs. The cost analysis carried during evaluation phase revealed the following. For \texttt{Bounded} class, the \ac{gsa} allocates storage better than the \ac{rlsa}. \ac{gsa} over allocates but within the set threshold, whereas the \ac{rlsa} under allocates at all instants of the application runtime. The cost incurred due to under allocating storage is out of the scope of this thesis, but it is observed that the agent continuously takes action because of the difference between \ac{rds} and the \ac{ads}. The allocation becomes so fine-grained and the \texttt{Downtime} keeps accumulating. Observing the storage allocated by the \ac{rl} agent, I conclude that the agent designed for the \texttt{Bounded} class require more episodes of training to come-up with a storage allocator that decides better. Even though there is no cost incurred on \texttt{Unused Disk Space} from the \ac{rlsa}, there is an unknown cost incurred due to under allocating storage. Concluding on which storage allocator would suit the class better is difficult at this point in time. Storage allocated for applications in the class \texttt{Bounded and Oscillating} depicts that the cost involved while using the \ac{gsa} is too high compared to the \ac{rlsa}. The cost incurred was due to \texttt{Unused Disk Space} in the \ac{gsa}. Although there is a cost incurred due to application downtime, in the \ac{rlsa}, it is negligible to that of the total cost of \ac{gsa}. 
